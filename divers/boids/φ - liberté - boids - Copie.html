<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>exemple de boids</title>
	<!--réalisé à partir du fichier https://github.com/jqlee85/boids de Jesse Lee -->
	
	<style>
		
	/*------------------------------------*\
		RESET
	\*------------------------------------*/
	/* http://meyerweb.com/eric/tools/css/reset/
		v2.0b1 | 201101
		NOTE:WORK IN PROGRESS
		USE WITH CAUTION AND TEST WITH ABANDON */

	html,body,div,span,applet,object,iframe,
	h1,h2,h3,h4,h5,h6,p,blockquote,pre,
	a,abbr,acronym,address,big,cite,code,
	del,dfn,em,img,ins,kbd,q,s,samp,
	small,strike,strong,sub,sup,tt,var,
	b,u,i,center,
	dl,dt,dd,ol,ul,li,
	fieldset,form,label,legend,
	table,caption,tbody,tfoot,thead,tr,th,td,
	article,aside,canvas,details,figcaption,figure,
	footer,header,hgroup,menu,nav,section,summary,
	time,mark,audio,video{
		margin:0;
		padding:0;
		border:0;
		outline:0;
		font-size:100%;
		font:inherit;
		vertical-align:baseline;
	}
	/* HTML5 display-role reset for older browsers */
	article,aside,details,figcaption,figure,
	footer,header,hgroup,menu,nav,section{
		display:block;
	}
	body{
		line-height:1;
	}
	ol,ul{
		list-style:none;
	}
	blockquote,q{
		quotes:none;
	}
	blockquote:before,blockquote:after,
	q:before,q:after{
		content:’’;
		content:none;
	}
	/* remember to define visible focus styles!
	:focus{
		outline:?????;
	} */

	/* remember to highlight inserts somehow! */
	ins{
		text-decoration:none;
	}
	del{
		text-decoration:line-through;
	}

	table{
		border-collapse:collapse;
		border-spacing:0;
	}


	/*------------------------------------*\
		$MAIN
	\*------------------------------------*/
	/* GO! */

	#home {
	  height: 100%;
	  height: 100vh;
	  width: 100%;
	  width: 100vw;
	  max-height: 100%;
	  max-height: 100vh;
	  max-width: 100%;
	  max-width: 100vw;
	  overflow: hidden;
	  background-color: #222;
	  color: #fafafa;

	  font-family: arial;
	}

	#boids-wrapper {
	  display: flex;
	  align-items: flex-end;
	  height: 100%;
	  height: 100vh;
	  width: 100%;
	  width: 100vw;
	  max-height: 100%;
	  max-height: 100vh;
	  max-width: 100%;
	  max-width: 100vw;
	  overflow: hidden;
	  position: relative;
	}

	#boids {
	  position: absolute;
	  height: 100%;
	  height: 100vh;
	  width: 100%;
	  width: 100vw;
	  max-height: 100%;
	  max-height: 100vh;
	  max-width: 100%;
	  max-width: 100vw;
	}


	#boids-controls-container {
	  position: relative;
	  bottom: 0;
	  z-index: 10;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  width: 100%;
	  height: auto;
	  padding: 20px 0;
	  text-transform: uppercase;
	}

	.boids-control {
	  box-sizing: border-box;
	  text-align: center;
	  font-family: arial;
	  text-transform: uppercase;
	  width: auto;
	  height: auto;
	  margin-left: 10px;
	  margin-right: 10px;
	  flex-wrap: wrap;
	}
	.boids-control-range label {

	}

	.range-slider .input-range {
		height: auto;
		margin-top: 12px;
		margin-bottom: 2px;
		background: none;
		outline: none;
		writing-mode: bt-lr; /* IE */
	}

	/* Firefox Overrides */
	::-moz-range-track {
		background: #ccc;
		border: 0;
	}

	input::-moz-focus-inner {
	  border: 0;
	}

	/* end Range Sliders */

	/* begin Checkbox */
	.boids-control-checkbox {
	  position: relative;
	}
	.checkbox {
	  position: relative;
	}
	.checkbox p {
	  z-index: 1;
	}
	.label-wrapper {
	  z-index: 1;
	  position:absolute;
	  width: 100%;
	  height: 15px;
	  margin-top: 10px;
	  margin-bottom: 2px;
	}
	.boids-control-checkbox label {
	  width: 15px;
	  height: 15px;
	  display: block;
	  position: relative;
	  box-sizing: border-box;
	  margin: auto;
	  top: -3px;
	  left: 0;
	  background: rgba(34,34,34,.8);
	  border: 1px solid #fff;
	  box-shadow: inset 0px 1px 1px rgba(0, 0, 0, 0.5), 0px 1px 0px rgba(255, 255, 255, 0.4);
	}
	.boids-control-checkbox label:after {
	  content: '';
	  width: 8px;
	  height: 5px;
	  position: absolute;
	  top: 1px;
	  left: 1px;
	  border: 3px solid #fcfff4;
	  border-top: none;
	  border-right: none;
	  background: transparent;
	  opacity: 0;
	  -webkit-transform: rotate(-45deg);
			  transform: rotate(-45deg);
	}
	.boids-control-checkbox label:hover::after {
	  opacity: 0.3;
	}
	.boids-control input[type=range], .boids-control-checkbox label {
	  cursor: pointer;
	}
	.boids-control-checkbox input[type=checkbox] {
	  height: 0px;
	  width: 15px;
	  margin: 0 !important;
	  visibility: hidden;
	  z-index: 10;
	  cursor: pointer;
	}
	.boids-control-checkbox input[type=checkbox]:checked + label:after {
	  opacity: 1;
	}
	/* end Checkbox */
	#fps {
	  position: absolute;
	  left:0;
	  bottom: 0;
	  font-size: 14px;
	  color: #fafafa;

	  padding: 5px;
	}
	#mobile-boids-controls {
	  text-align: center;
	  display: flex;
	  align-items: center;
	  justify-content: center;
	}
	#mobile-boids-controls button {
	  background: none;
	  margin: 8px 3px 0px;
	  color: #fafafa;

	  border: 1px solid rgba(255,255,255,.8);
	  border-radius: 0;
	  cursor: pointer;
	  text-align: center;
	}
	#mobile-boids-controls button:focus {
	  outline:0;
	}
	#mobile-boids-controls button.boids-checkbox-on {
	  background-color: #fafafa;

	  color: #000;
	}
	.boids-control-close {
	  display: none;
	  box-sizing:border-box;
	  position: absolute;
	  width: 20px;
	  height: 20px;
	  top: 0;
	  right: 20px;
	  color: #fafafa;

	  cursor: pointer;
	}
	.boids-control-close:hover::before, .boids-control-close:hover::after {
	  background: #1ebcc5;
	}
	.boids-control-close::before, .boids-control-close::after {
	  content: '';
	  position: absolute;
	  height: 2px;
	  width: 100%;
	  top: 50%;
	  left: 0;
	  margin-top: -1px;
	  background: #fafafa;
	  background: rgba(255,255,255,.8);
	}
	.boids-control-close::before {
	  -webkit-transform: rotate(45deg);
	  -moz-transform: rotate(45deg);
	  -ms-transform: rotate(45deg);
	  -o-transform: rotate(45deg);
	  transform: rotate(45deg);
	}
	.boids-control-close::after {
	  -webkit-transform: rotate(-45deg);
	  -moz-transform: rotate(-45deg);
	  -ms-transform: rotate(-45deg);
	  -o-transform: rotate(-45deg);
	  transform: rotate(-45deg);
	}
	.boids-control-close.big {
	  -webkit-transform: scale(3);
	  -moz-transform: scale(3);
	  -ms-transform: scale(3);
	  -o-transform: scale(3);
	  transform: scale(3);
	}
	#jumpoff-link {
	  position: absolute;
	  display: inline;
	  bottom: 0;
	  right: 0;
	  background: none;
	  padding: 5px;
	}
	#jumpoff-link a, #jumpoff-link a:visited {
	  font-size: 14px;
	  color: #fafafa;

	  text-decoration: none;
	  cursor: pointer;
	}
	#jumpoff-link a:hover {
	  color: #fff;
	}
	@media screen and (max-width: 1000px) {
	  #boids-controls-container {
		padding: 16px 0;
	  }
	  .boids-control {
		display: block;
		position: absolute;
		background: rgba(34,34,34,.8);
		width: 100%;
		padding: 0px 0px;
		margin: 0;
		max-height: 0px;
		-webkit-transition: max-height .5s ease-in-out, padding .5s ease-in-out;
		-moz-transition: max-height .5s ease-in-out, padding .5s ease-in-out;
		-o-transition: max-height .5s ease-in-out, padding .5s ease-in-out;
		transition: max-height .5s ease-in-out, padding .5s ease-in-out;
		bottom: 0px;
	  }
	  .boids-control.show {
		position: relative;
		height: auto;
		max-height: 80px;
		padding: 20px 0;
	  }
	  .boids-control-close {
		display: inline-block;
	  }
	  #mobile-boids-controls {
		display: block;
	  }
	  #fps, #jumpoff-link {
		font-size: 10px;
		padding: 3px;
	  }
	  #jumpoff-link a {
		font-size: 10px;
	  }
	}
	@media screen and (min-width: 1001px) {
	  #mobile-boids-controls {
		display: none;
	  }
	}

	</style>
	
	<!--[if IE]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<!--[if IE]>	
	https://jumpoff.io/boids/](https://jumpoff.io/boids/
	<![endif]-->
</head>

<body id="home">

  <div id="boids-wrapper">
    <canvas id="boids"></canvas>
		<div id="boids-controls-container">
			<div id="mobile-boids-controls">
				<button id="introversion-mobile">Introversion</button>
				<button id="speed-mobile">Vitesse</button>
				<button id="walls-mobile" class="boids-checkbox-on">Murs</button>
				<button id="collisions-mobile">Collisions</button>
				<button id="mouse-seek-mobile">Chercher la souris</button>
				<button id="racism-mobile">Racisme</button>
				<button id="diversity-mobile">Diversité</button>
			</div>
			<div id="introversion-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Introversion</p></label>
					<input class="input-range" type="range" step="1" value="5" min="0" max="10" name="introversion" id="introversion">
			    <span class="range-value"></span>
				</div>
			</div>
			<div id="speed-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Vitesse</p></label>
					<input class="input-range" type="range" step="1" value="5" min="0" max="10" name="speed" id="speed">
			    <span class="range-value"></span>
				</div>
			</div>
			<div class="boids-control boids-control-checkbox">
				<div class="checkbox">
					<p>Murs</p>
					<input type="checkbox" id="walls" name="walls"/>
					<label for="walls"></label>
				</div>
			</div>
			<div class="boids-control boids-control-checkbox">
				<div class="checkbox">
					<p>Collisions</p>
					<input type="checkbox" id="collision-detection" name="collision-detection"/>
					<label for="collision-detection"></label>
				</div>
			</div>
			<div class="boids-control boids-control-checkbox">
				<div class="checkbox">
					<p>Chercher la souris</p>
					<input type="checkbox" id="mouse-seek" name="mouse-seek"/>
					<label for="mouse-seek"></label>
				</div>
			</div>
			<div id="racism-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Racisme</p></label>
					<input class="input-range" type="range" step="1" value="0" min="0" max="10" name="racism" id="racism">
			    <span class="range-value"></span>
				</div>
			</div>
			<div id="diversity-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Diversité</p></label>
					<input class="input-range" type="range" step="1" value="8" min="1" max="8" name="diversity" id="diversity">
			    <span class="range-value"></span>
				</div>
			</div>
			<div id="fps">
				<p><span id="fps-number"></span> fps</p>
			</div>

		</div>
	</div>

  <script>
  /*!
MIT License

Copyright (c) 2011 Max Kueng, George Crabtree
 
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
 
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
!function(t){if("object"==typeof exports)module.exports=t();else if("function"==typeof define&&define.amd)define(t);else{var i;"undefined"!=typeof window?i=window:"undefined"!=typeof global?i=global:"undefined"!=typeof self&&(i=self),i.Victor=t()}}(function(){return function t(i,r,n){function o(s,h){if(!r[s]){if(!i[s]){var u="function"==typeof require&&require;if(!h&&u)return u(s,!0);if(e)return e(s,!0);throw new Error("Cannot find module '"+s+"'")}var p=r[s]={exports:{}};i[s][0].call(p.exports,function(t){var r=i[s][1][t];return o(r?r:t)},p,p.exports,t,i,r,n)}return r[s].exports}for(var e="function"==typeof require&&require,s=0;s<n.length;s++)o(n[s]);return o}({1:[function(t,i,r){function n(t,i){return this instanceof n?(this.x=t||0,void(this.y=i||0)):new n(t,i)}function o(t,i){return Math.floor(Math.random()*(i-t+1)+t)}function e(t){return t*h}function s(t){return t/h}r=i.exports=n,n.fromArray=function(t){return new n(t[0]||0,t[1]||0)},n.fromObject=function(t){return new n(t.x||0,t.y||0)},n.prototype.addX=function(t){return this.x+=t.x,this},n.prototype.addY=function(t){return this.y+=t.y,this},n.prototype.add=function(t){return this.x+=t.x,this.y+=t.y,this},n.prototype.addScalar=function(t){return this.x+=t,this.y+=t,this},n.prototype.addScalarX=function(t){return this.x+=t,this},n.prototype.addScalarY=function(t){return this.y+=t,this},n.prototype.subtractX=function(t){return this.x-=t.x,this},n.prototype.subtractY=function(t){return this.y-=t.y,this},n.prototype.subtract=function(t){return this.x-=t.x,this.y-=t.y,this},n.prototype.subtractScalar=function(t){return this.x-=t,this.y-=t,this},n.prototype.subtractScalarX=function(t){return this.x-=t,this},n.prototype.subtractScalarY=function(t){return this.y-=t,this},n.prototype.divideX=function(t){return this.x/=t.x,this},n.prototype.divideY=function(t){return this.y/=t.y,this},n.prototype.divide=function(t){return this.x/=t.x,this.y/=t.y,this},n.prototype.divideScalar=function(t){return 0!==t?(this.x/=t,this.y/=t):(this.x=0,this.y=0),this},n.prototype.divideScalarX=function(t){return 0!==t?this.x/=t:this.x=0,this},n.prototype.divideScalarY=function(t){return 0!==t?this.y/=t:this.y=0,this},n.prototype.invertX=function(){return this.x*=-1,this},n.prototype.invertY=function(){return this.y*=-1,this},n.prototype.invert=function(){return this.invertX(),this.invertY(),this},n.prototype.multiplyX=function(t){return this.x*=t.x,this},n.prototype.multiplyY=function(t){return this.y*=t.y,this},n.prototype.multiply=function(t){return this.x*=t.x,this.y*=t.y,this},n.prototype.multiplyScalar=function(t){return this.x*=t,this.y*=t,this},n.prototype.multiplyScalarX=function(t){return this.x*=t,this},n.prototype.multiplyScalarY=function(t){return this.y*=t,this},n.prototype.normalize=function(){var t=this.length();return 0===t?(this.x=1,this.y=0):this.divide(n(t,t)),this},n.prototype.norm=n.prototype.normalize,n.prototype.limit=function(t,i){return Math.abs(this.x)>t&&(this.x*=i),Math.abs(this.y)>t&&(this.y*=i),this},n.prototype.randomize=function(t,i){return this.randomizeX(t,i),this.randomizeY(t,i),this},n.prototype.randomizeX=function(t,i){var r=Math.min(t.x,i.x),n=Math.max(t.x,i.x);return this.x=o(r,n),this},n.prototype.randomizeY=function(t,i){var r=Math.min(t.y,i.y),n=Math.max(t.y,i.y);return this.y=o(r,n),this},n.prototype.randomizeAny=function(t,i){return Math.round(Math.random())?this.randomizeX(t,i):this.randomizeY(t,i),this},n.prototype.unfloat=function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},n.prototype.toFixed=function(t){return"undefined"==typeof t&&(t=8),this.x=this.x.toFixed(t),this.y=this.y.toFixed(t),this},n.prototype.mixX=function(t,i){return"undefined"==typeof i&&(i=.5),this.x=(1-i)*this.x+i*t.x,this},n.prototype.mixY=function(t,i){return"undefined"==typeof i&&(i=.5),this.y=(1-i)*this.y+i*t.y,this},n.prototype.mix=function(t,i){return this.mixX(t,i),this.mixY(t,i),this},n.prototype.clone=function(){return new n(this.x,this.y)},n.prototype.copyX=function(t){return this.x=t.x,this},n.prototype.copyY=function(t){return this.y=t.y,this},n.prototype.copy=function(t){return this.copyX(t),this.copyY(t),this},n.prototype.zero=function(){return this.x=this.y=0,this},n.prototype.dot=function(t){return this.x*t.x+this.y*t.y},n.prototype.cross=function(t){return this.x*t.y-this.y*t.x},n.prototype.projectOnto=function(t){var i=(this.x*t.x+this.y*t.y)/(t.x*t.x+t.y*t.y);return this.x=i*t.x,this.y=i*t.y,this},n.prototype.horizontalAngle=function(){return Math.atan2(this.y,this.x)},n.prototype.horizontalAngleDeg=function(){return e(this.horizontalAngle())},n.prototype.verticalAngle=function(){return Math.atan2(this.x,this.y)},n.prototype.verticalAngleDeg=function(){return e(this.verticalAngle())},n.prototype.angle=n.prototype.horizontalAngle,n.prototype.angleDeg=n.prototype.horizontalAngleDeg,n.prototype.direction=n.prototype.horizontalAngle,n.prototype.rotate=function(t){var i=this.x*Math.cos(t)-this.y*Math.sin(t),r=this.x*Math.sin(t)+this.y*Math.cos(t);return this.x=i,this.y=r,this},n.prototype.rotateDeg=function(t){return t=s(t),this.rotate(t)},n.prototype.rotateTo=function(t){return this.rotate(t-this.angle())},n.prototype.rotateToDeg=function(t){return t=s(t),this.rotateTo(t)},n.prototype.rotateBy=function(t){var i=this.angle()+t;return this.rotate(i)},n.prototype.rotateByDeg=function(t){return t=s(t),this.rotateBy(t)},n.prototype.distanceX=function(t){return this.x-t.x},n.prototype.absDistanceX=function(t){return Math.abs(this.distanceX(t))},n.prototype.distanceY=function(t){return this.y-t.y},n.prototype.absDistanceY=function(t){return Math.abs(this.distanceY(t))},n.prototype.distance=function(t){return Math.sqrt(this.distanceSq(t))},n.prototype.distanceSq=function(t){var i=this.distanceX(t),r=this.distanceY(t);return i*i+r*r},n.prototype.length=function(){return Math.sqrt(this.lengthSq())},n.prototype.lengthSq=function(){return this.x*this.x+this.y*this.y},n.prototype.magnitude=n.prototype.length,n.prototype.isZero=function(){return 0===this.x&&0===this.y},n.prototype.isEqualTo=function(t){return this.x===t.x&&this.y===t.y},n.prototype.toString=function(){return"x:"+this.x+", y:"+this.y},n.prototype.toArray=function(){return[this.x,this.y]},n.prototype.toObject=function(){return{x:this.x,y:this.y}};var h=180/Math.PI},{}]},{},[1])(1)});
  </script>
  
  
  <script>
class Boid {

  /**
   * Contstruct Boid object
   *
   * @param  object | boid | Initial setup properties for boid
   *
   */
  constructor(boid) {

    // Initial Properties
    this.id = boid.id;
    this.position = new Victor( boid.x, boid.y );
    this.radius = boid.radius * radiusCoefficients[ boid.radiusCoefficient ];
    this.introversionCoefficient = boid.introversionCoefficient;
    this.introversion = boid.introversion * this.introversionCoefficient;
    this.quicknessCoefficient = boid.quicknessCoefficient;
    this.quickness = boid.quickness * this.quicknessCoefficient;
    this.racismCoefficient = boid.racismCoefficient;
    this.racism = boid.racism * boid.racismCoefficient;
    this.color = boid.color;
    this.mass = (4/3) * Math.PI * Math.pow( this.radius,3 );

    // Speed & Velocity & Force
    this.maxSpeed = speedIndex * this.quickness;
    this.speed = this.maxSpeed * .5;
    var radians = Math.PI * getRandomInt(-99,100) / 100;
    this.velocity = new Victor( this.speed * Math.cos( radians ), this.speed * Math.sin( radians ) );
    //Force and Accel
    this.maxForce = .5;

  }

  /**
   * Calculate the seek force for a boid and a target
   *
   * @param  object | target | The Victor.js vector for a target's position
   * @return object | The seek force for the target as a vector
   */
  seek( target ){
    var targetposition = target.clone();
    var diff = targetposition.subtract(this.position);
    var desired = new Victor(diff.x,diff.y);

    if (target.radius) {
      var buffer = target.radius + this.radius + 1;
    } else {
      var buffer = this.radius * 2 + 1;
    }

    var dist = diff.magnitude();
    if (dist < buffer) {
      desired.x = 0;
      desired.y = 0;
    } else if ( dist <= 100 ) {
      desired.normalize();
      desired.divide({x:this.maxSpeed * dist / 100,y:this.maxSpeed * dist / 100});
    } else {
      desired.limitMagnitude(this.maxSpeed);
    }
    desired.subtract(this.velocity);
    desired.limitMagnitude(this.maxForce);
    return desired;
  }

  /**
   * Calculate the separation force for a boid and its flock
   *
   * @param  array | boids | The boids array containing all the boids
   * @return object | The Separation force as a Victor vector
   */
  separate( boids ){
    var sum = new Victor();
    var count = 0;
    for (var j = 0; j < boids.length; j++) {
      if ( this.color != boids[j].color ) {
        var racismMultiplier = this.racism;
      } else {
        var racismMultiplier = 0;
      }
      var desiredSeparation = this.radius + boids[j].radius + ( 25 * this.introversion ) + ( 50 * racismMultiplier );
      var sep = this.position.clone().distance(boids[j].position);
      if ( (sep > 0) && (sep < desiredSeparation) ) {
        var thisposition = this.position.clone();
        var diff = thisposition.subtract(boids[j].position);
        diff.normalize();
        diff.divide({x:sep,y:sep});
        sum.add(diff);
        count++;
      }
    }
    if (count > 0) {
      sum.divide({x:count,y:count});
      sum.normalize();
      sum.multiply({x:this.maxSpeed,y:this.maxSpeed});
      sum.subtract(this.velocity);
      sum.limitMagnitude(this.maxForce);
    }
    return sum;
  }

  /**
   * Calculate the alignment force for a boid and its flock
   *
   * @param  array | boids | The boids array containing all the boids
   * @return object | The alignment force as a Victor vector
   */
  align( boids ) {
    var neighborDist = 50;
    var sum = new Victor();
    var steer = new Victor();
    var count = 0;
    for (var i = 0; i < boids.length; i++) {
      var dist = this.position.distance(boids[i].position);
      if ( dist > 0 && dist < neighborDist ) {
        sum.add(boids[i].velocity);
        count++;
      }
    }
    if (count > 0) {
      sum.divide({x:count,y:count});
      sum.normalize()
      sum.multiply({x:this.maxSpeed,y:this.maxSpeed});
      steer = sum.subtract(this.velocity);
      steer.limitMagnitude(this.maxForce);
      return steer;
    } else {
      return steer;
    }
  }

  /**
   * Calculate the cohesion force for a boid and its flock
   *
   * @param  array | boids | The boids array containing all the boids
   * @return object | The cohesion force as a Victor vector
   */
  cohesion( boids ) {
    var neighborDist = 50;
    var sum = new Victor();
    var count = 0;
    for (var i = 0; i < boids.length; i++) {
      var dist = this.position.distance(boids[i].position);
      if ( dist > 0 && dist < neighborDist ) {
        sum.add(boids[i].position);
        count++;
      }
    }
    if (count > 0) {
      sum.divide({x: count,y:count});
      return this.seek(sum);
    } else {
      return sum;
    }
  }

  /**
   * Avoid the canvas walls if walls are enabled
   *
   * @return object/boolean | The seek force to avoid a wall, or false if not near a wall
   */
  avoidWalls() {

    var buffer = mobile ? 5 : 15;

    if ( this.distanceFromHorWall() < this.radius * buffer || this.distanceFromVertWall() < this.radius * buffer ) {
      return this.seek(center);
    } else { return false; }

  }

  /**
   * Run force calculation functions for the boid, then apply forces
   *
   */
  flock() {

    // Get Forces
    var alignForce = this.align(boids);
    if ( mouseSeek ) var mouseForce = this.seek(mouse.position);
    var separateForce = this.separate(boids);
    var cohesionForce = this.cohesion(boids);
    if ( walls ) var avoidWallsForce = this.avoidWalls();

    // Weight Forces
    var alignWeight = 1.2;
    if ( mouseSeek ) var mouseWeight = .2;
    var separateWeight = 1;
    var cohesionWeight = 1;
    if ( walls ) var avoidWallsWeight = 1.2;


    // Apply forces
    this.applyForce( alignForce, alignWeight );
    if ( mouseSeek ) this.applyForce( mouseForce, mouseWeight );
    this.applyForce( separateForce, separateWeight );
    this.applyForce( cohesionForce, cohesionWeight );
    if ( walls && avoidWallsForce ) this.applyForce( avoidWallsForce, avoidWallsWeight );

  }

  /**
   * Apply a coefficient to a given force and apply it to the boid
   *
   * @param object | force | The Victor vector of the force to be applied
   * @param float | coefficient | The factor to be applied to the force
   */
  applyForce( force, coefficient ) {
    if ( ! coefficient ) { var coefficient = 1; }
    force.multiply({x:coefficient,y:coefficient});
    this.velocity.add(force);
    this.velocity.limitMagnitude( this.maxSpeed );
  }

  /**
   * Run the flock function and update the boid's position based on the resulting velocity
   *
   */
  nextPosition() {

    // Loop through behaviors to apply forces
    this.flock();

    // Update position
    this.position = this.position.add(this.velocity);

    // Collision detection if enabled
    if ( collisions ) { this.detectCollision(); }

    // Check edges for walls or overruns
    this.edgeCheck();

  }

  /**
   * Check for edge crossings and bounce the boid or wrap it to the other side of the canvas
   *
   */
  edgeCheck() {
    if (walls) {
      this.wallBounce();
    } else {
      this.borderWrap();
    }
  }

  /**
   * If the boid passes a border with no walls, wrap the boid to the other side of the canvas
   *
   */
  borderWrap() {
    if (this.position.x < 0) {
      this.position.x = document.body.clientWidth;
    } else if ( this.position.x > document.body.clientWidth ) {
      this.position.x = 0;
    }
    if (this.position.y < 0) {
      this.position.y = document.body.clientHeight;
    } else if ( this.position.y > document.body.clientHeight ) {
      this.position.y = 0;
    }
  }

  /**
   * Detect a wall hit and bounce boid
   *
   */
  wallBounce() {
    if (this.position.x <= this.radius) {
      this.position.x = this.radius;
    } else if ( this.position.x >= document.body.clientWidth - this.radius) {
      this.position.x = document.body.clientWidth - this.radius;
    }
    if (this.position.y <= this.radius) {
      this.position.y = this.radius;
    } else if ( this.position.y >= document.body.clientHeight - this.radius ) {
      this.position.y = document.body.clientHeight - this.radius;
    }
    if ( this.distanceFromHorWall() <= this.radius  ) {
      this.velocity.invertY();
    }
    if ( this.distanceFromVertWall() <= this.radius  ) {
      this.velocity.invertX();
    }
  }

  /**
   * Calculate the distance from vertical wall in the direction of the boid's velocity
   *
   * @param float | the boid's distance from the wall
   */
  distanceFromVertWall() {
    if (this.velocity.x > 0) {
      return document.body.clientWidth - ( this.position.x );
    } else {
      return this.position.x;
    }

  }

  /**
   * Calculate the distance from horizontal wall in the direction of the boid's velocity
   *
   * @param float | the boid's distance from the wall
   */
  distanceFromHorWall() {
    if (this.velocity.y > 0) {
      return document.body.clientHeight - ( this.position.y );
    } else {
      return this.position.y;
    }
  }

  /**
   * Draw Boid to the canvas
   *
   */
  draw(){
    c.beginPath();
    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2, false);
    c.fillStyle = this.color;
    c.fill();
    c.closePath();
  }

  /**
   * Update a boid's position and call draw()
   *
   */
  update() {

    this.nextPosition();
    this.draw();

  }

  /**
   * Detect collisions between boids and resolve
   *
   */
  detectCollision(){

    for (var i = 0; i < boids.length; i++) {
      if ( this === boids[i] ) { continue; }
      if ( getDistance( this.position.x, this.position.y, boids[i].position.x, boids[i].position.y) - ( this.radius + boids[i].radius ) < 0 ) {
        this.resolveCollision( this, boids[i]);
      }
    }
  }

/**
 * Rotates coordinate system for velocities
 * Takes velocities and alters them as if the coordinate system they're on was rotated
 *
 * @param  object | velocity | The velocity of an individual boid
 * @param  float  | angle    | The angle of collision between two objects in radians
 * @return object | The altered x and y velocities after the coordinate system has been rotated
 */
  rotate(velocity, angle) {
    return {
        x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
        y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
    };
  }

  /**
   * Swaps out two colliding boids' x and y velocities after running through
   * an elastic collision reaction equation
   *
   * @param  object | boid      | A boid object
   * @param  object | otherBoid | A boid object
   */
   resolveCollision(boid, otherBoid) {

      var xVelocityDiff = boid.velocity.x - otherBoid.velocity.x;
      var yVelocityDiff = boid.velocity.y - otherBoid.velocity.y;

      var xDist = otherBoid.position.x - boid.position.x;
      var yDist = otherBoid.position.y - boid.position.y;

      // Prevent accidental overlap of boids
      if ( xVelocityDiff * xDist + yVelocityDiff * yDist >= 0 ) {

        // Grab angle between the two colliding boids
        var angle = -Math.atan2(otherBoid.position.y - boid.position.y, otherBoid.position.x - boid.position.x);

        // Store mass in var for better readability in collision equation
        var m1 = boid.mass;
        var m2 = otherBoid.mass;

        // Velocity before equation
        var u1 = this.rotate(boid.velocity, angle);
        var u2 = this.rotate(otherBoid.velocity, angle);

        // Velocity after 1d collision equation
        var v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };
        var v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y };

        // Final velocity after rotating axis back to original position
        var vFinal1 = this.rotate(v1, -angle);
        var vFinal2 = this.rotate(v2, -angle);

        // Swap boid velocities for realistic bounce effect
        boid.velocity.x = vFinal1.x;
        boid.velocity.y = vFinal1.y;
        boid.velocity.limitMagnitude(boid.maxSpeed);

        otherBoid.velocity.x = vFinal2.x;
        otherBoid.velocity.y = vFinal2.y;
        otherBoid.velocity.limitMagnitude(otherBoid.maxSpeed);
      }

    }

}
  </script>
  
  
  <script>
  
  /*
 *  JumpOff JavaScript Boids
 *
 *  Copyright 2017, JumpOff, LLC
 *  Github:  https://github.com/jqlee85/boids
 *  Author: JumpOff, LLC
 *  Author URL: https://jumpoff.io
 *
 *  License: WTFPL license
 *  License URL: http://sam.zoy.org/wtfpl/
 *
 *  Version: 1.0
 */

/*---- Global Setup ----*/

// Set up canvas
const canvas = document.getElementById('boids');
const c = canvas.getContext('2d');

// Get Firefox
var browser=navigator.userAgent.toLowerCase();
if(browser.indexOf('firefox') > -1) {
  var firefox = true;
}

// Detect Mobile
var mobile = ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) ? true : false;

// Set Size
var size = {
  width: window.innerWidth || document.body.clientWidth,
  height: window.innerHeight || document.body.clientHeight
}
canvas.width = size.width;
canvas.height = size.height;
var center = new Victor( size.width / 2 ,size.height / 2 );

// Initialize Mouse
var mouse = {
  position: new Victor( innerWidth / 2, innerHeight / 2 )
};

/*---- end Global Setup ----*/

/*---- Helper Functions ----*/

/**
 * Returns a random int between a min and a max
 *
 * @param  int | min | A minimum number
 * @param  int | max | A maximum number
 * @return int | The random number in the given range
 */
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Returns the distance between two coordinates
 *
 * @param  int | x1 | Point 1's x coordinate
 * @param  int | y1 | Point 1's y coordinate
 * @param  int | x2 | Point 2's x coordinate
 * @param  int | y2 | Point 2's y coordinate
 * @return int | The distance between points 1 and 2
 */
function getDistance(x1, y1, x2, y2) {
  var xDist = x2 - x1;
  var yDist = y2 - y1;
  return Math.sqrt( Math.pow(xDist, 2) + Math.pow(yDist, 2) );
}

/**
 * Returns a random color from the colors array
 *
 * @param  array | colors | An array of color values
 * @return string | The random color value
 */
function randomColor(colors) {
  return colors[ Math.floor( Math.random() * colors.length) ];
}

/**
 * Get coefficients based on normal distribution
 *
 * @param  int | mean | The mean value of the data set
 * @param  int | stdev | The standard deviation for the data set
 * @return int | A number from the data set
 */
function gaussian(mean, stdev) {
    var y2;
    var use_last = false;
    return function() {
        var y1;
        if(use_last) {
           y1 = y2;
           use_last = false;
        }
        else {
            var x1, x2, w;
            do {
                 x1 = 2.0 * Math.random() - 1.0;
                 x2 = 2.0 * Math.random() - 1.0;
                 w  = x1 * x1 + x2 * x2;
            } while( w >= 1.0);
            w = Math.sqrt((-2.0 * Math.log(w))/w);
            y1 = x1 * w;
            y2 = x2 * w;
            use_last = true;
       }

       var retval = mean + stdev * y1;
       if(retval > 0)
           return retval;
       return -retval;
   }
}
var getCoefficient = gaussian(50, 9);
var getQuicknessCoefficient = gaussian(75,7.5);

/**
 * Add Limit Magnitude function to Victor objects
 *
 * @param  int | max | The limit magnitude for the vector
 */
Victor.prototype.limitMagnitude = function (max) {

  if (this.length() > max) {
    this.normalize();
    this.multiply({x:max,y:max});
  }

};

/*--- end Helper Functions ----*/

/*---- Loop and Initializing ----*/

// Checkbox Options
var walls = true;
var mouseSeek = false;
var collisions = false;

// Set number of boids based on browser and screen size
if (firefox) {
  var maxBoids = 250;
} else if (mobile) {
  var maxBoids = 150;
} else {
  var maxBoids = 500;
}
var minBoids = 250;
var numBoids = Math.sqrt(canvas.width * canvas.height) / 2;
if ( numBoids > maxBoids ) {
  numBoids = maxBoids;
} else if ( numBoids < minBoids ) {
  numBoids = minBoids;
}

// Set possible radii  based on screen size
var radius;
if ( size.width / 288 > 5 ) {
  radius = 5;
} else if ( size.width / 288 < 3) {
  radius = 3;
} else {
  radius = size.width / 288;
}
var radiusCoefficients = [.5,.6,.7,.8,1];

// Boid Attributes
var colors = [
  '#4286f4',
  '#f4416a',
  '#41f4a0',
  '#f9f9f9',
  '#a341f4',
  '#f48341',
  '#f4e841',
  '#42ebf4'
];
var diversity = 8;
var quickness = 1;
var introversion = .5;
var racism = 0;
var speedIndex;
if ( size.width / 160 < 5 ) {
  speedIndex = 5;
} else if ( size.width / 180 > 8 ) {
  speedIndex = 9;
} else {
  speedIndex = size.width / 180;
}

// Create Boids Array
var boids = [];

/**
 * Create Boids Array
 *
 */
function createBoids() {

  // Instantiate all Boids
  for ( i = 0; i < numBoids; i++ ) {

    // Generate introversion coefficient
    var introversionCoefficient = getCoefficient() / 100;
    var quicknessCoefficient = getQuicknessCoefficient() / 100;
    var racismCoefficient = getCoefficient() / 100;
    var radiusCoefficient = Math.floor(Math.random() * radiusCoefficients.length);

    // Generate random coords
    var x = Math.ceil(Math.random()* ( size.width - ( radius * 2 ) ) ) + ( radius );
    var y = Math.ceil(Math.random()* ( size.height - ( radius * 2 ) ) ) + ( radius );
    // For subsequent boids, check for collisions and generate new coords if exist
    if ( i !== 0 ) {
      for (var j = 0; j < boids.length; j++ ) {
        if ( getDistance(x, y, boids[j].x, boids[j].y) - ( radius + boids[j].radius ) < 0 ) {
          x = Math.ceil(Math.random()* ( size.width - ( radius * 2 ) ) ) + ( radius );
          y = Math.ceil(Math.random()* ( size.height - ( radius * 2 ) ) ) + ( radius );
          j = -1;
        }
      }
    }

    // Add new Boid to array
    boids.push( new Boid( {
      id: i,
      x: x,
      y: y,
      speedIndex: speedIndex,
      radius: radius,
      radiusCoefficient: radiusCoefficient,
      quickness: quickness,
      quicknessCoefficient: quicknessCoefficient,
      color: randomColor(colors),
      racism: racism,
      racismCoefficient: racismCoefficient,
      introversion: introversion,
      introversionCoefficient: introversionCoefficient
    } ) );
  }

}

/**
 * Setup and call animation function
 *
 */
function animate() {
  requestAnimationFrame(animate);

  // Calc elapsed time since last loop
  now = Date.now();
  elapsed = now - then;

  // FPS Reporting
  fpsReport++;
  if (fpsReport > 60) {
    fpsNum.innerHTML = Math.floor(1000/elapsed);
    fpsReport = 0;
  }

  // If enough time has elapsed, draw the next frame
  if (elapsed > fpsInterval) {
      // Get ready for next frame by setting then=now, but also adjust for your
      // specified fpsInterval not being a multiple of RAF's interval (16.7ms)
      then = now - (elapsed % fpsInterval);
      // Drawing Code
      c.clearRect(0, 0, canvas.width, canvas.height);
      // Update all boids
      for (var i = 0; i < boids.length; i++ ) {
        boids[i].update();
      }
  }
}

// Setup animation
var stop = false;
var frameCount = 0;
var fps, fpsInterval, startTime, now, then, elapsed;
var fpsNum = document.getElementById('fps-number');
var fpsReport = 58;

/**
 * Start Animation of Boids
 *
 */
function startAnimating() {
  if(fps == null) { var fps = 60; }
  fpsInterval = 1000 / fps;
  then = Date.now();
  startTime = then;
  animate();
}

//Initalize program
createBoids();
startAnimating(60);

/*---- end Loop and Initializing ----*/

/*---- Event Listeners ----*/

/**
 * Update mouse positions on mousemove
 *
 */
addEventListener('mousemove', function(event){
  mouse.position.x = event.clientX;
  mouse.position.y = event.clientY;
});

/**
 * Update boundary sizes on window resize
 *
 */
addEventListener('resize', function(){
  size.width = innerWidth;
  size.height = innerHeight;
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  center.x = size.width/ 2;
  center.y = size.height / 2;
  if ( innerWidth >= 1000 && ! mobile ) {
    document.getElementById('mobile-boids-controls').style.display = 'none';
  } else {
    document.getElementById('mobile-boids-controls').style.display = 'block';
  }
});

/*---- end Event Listeners ----*/

/*---- Inputs ----*/

// Hide Elements on Mobile
document.getElementById('collisions-mobile').style.display = 'none';
document.getElementById('mouse-seek-mobile').style.display = 'none';

// Mobile Closers
var mobileClosers = document.getElementsByClassName('boids-control-close');
for (var i = 0; i < mobileClosers.length; i++) {
  mobileClosers[i].onclick = function() {
    this.parentNode.classList.toggle('show');
    document.getElementById('mobile-boids-controls').style.display = 'block';
  }
}

// Walls
var wallsInput = document.getElementById('walls');
wallsInput.checked = true;
wallsInput.onclick = function() {
  if ( !this.checked ) {
    this.checked = false;
    wallsMobile.dataset.checked = false;
    wallsMobile.classList.toggle('boids-checkbox-on');
    walls = false;
  } else {
    this.checked = true;
    wallsMobile.dataset.checked = true;
    wallsMobile.classList.toggle('boids-checkbox-on');
    walls = true;
  }
}
var wallsMobile = document.getElementById('walls-mobile');
wallsMobile.dataset.checked = true;
wallsMobile.onclick = function() {
  if ( this.dataset.checked == 'false') {
    this.dataset.checked = true;
    wallsInput.checked = true;
    this.classList.toggle('boids-checkbox-on');
    walls = true;
  } else {
    this.dataset.checked = false;
    wallsInput.checked = false;
    this.classList.toggle('boids-checkbox-on');
    walls = false;
  }
}

// Collision Detection
var collisionDetectionInput = document.getElementById('collision-detection');
collisionDetectionInput.checked = false;
collisionDetectionInput.onclick = function() {
  if ( !this.checked ) {
    this.checked = false;
    collisionDetectionMobile.dataset.checked = false;
    collisionDetectionMobile.classList.toggle('boids-checkbox-on');
    collisions = false;
  } else {
    this.checked = true;
    collisionDetectionMobile.dataset.checked = true;
    collisionDetectionMobile.classList.toggle('boids-checkbox-on');
    collisions = true;
  }
}
var collisionDetectionMobile = document.getElementById('collisions-mobile');
collisionDetectionMobile.dataset.checked = false;
collisionDetectionMobile.onclick = function() {
  if ( this.dataset.checked == 'false') {
    this.dataset.checked = true;
    collisionDetectionInput.checked = true;
    this.classList.toggle('boids-checkbox-on');
    collisions = true;
  } else {
    this.dataset.checked = false;
    collisionDetectionInput.checked = false;
    this.classList.toggle('boids-checkbox-on');
    collisions = false;
  }
}

// Mouse Seek
var mouseSeekInput = document.getElementById('mouse-seek');
mouseSeekInput.checked = false;
mouseSeekInput.onclick = function() {
  if ( !this.checked ) {
    this.checked = false;
    mouseSeekMobile.dataset.checked = false;
    mouseSeekMobile.classList.toggle('boids-checkbox-on');
    mouseSeek = false;
  } else {
    this.checked = true;
    mouseSeekMobile.dataset.checked = true;
    mouseSeekMobile.classList.toggle('boids-checkbox-on');
    mouseSeek = true;
  }
}
var mouseSeekMobile = document.getElementById('mouse-seek-mobile');
mouseSeekMobile.dataset.checked = false;
mouseSeekMobile.onclick = function() {
  if ( this.dataset.checked == 'false') {
    this.dataset.checked = true;
    mouseSeekInput.checked = true;
    this.classList.toggle('boids-checkbox-on');
    mouseSeek = true;
  } else {
    this.dataset.checked = false;
    mouseSeekInput.checked = false;
    this.classList.toggle('boids-checkbox-on');
    mouseSeek = false;
  }
}

// Introversion
var introversionControlContainer = document.getElementById('introversion-control-container');
var introversionInput = document.getElementById('introversion');
introversionInput.onchange = function() {
  introversion = this.value / 10;
  updateIntroversion(introversion);
}
var introversionMobile = document.getElementById('introversion-mobile');
introversionMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  introversionControlContainer.classList.toggle('show');
}
function updateIntroversion(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].introversion = value * boids[i].introversionCoefficient;
  }
}

// Speed
var speedControlContainer = document.getElementById('speed-control-container');
var speedInput = document.getElementById('speed');
speedInput.onchange = function() {
  quickness = this.value / 10 + .5;
  updateQuickness(quickness);
}
var speedMobile = document.getElementById('speed-mobile');
speedMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  speedControlContainer.classList.toggle('show');
}
function updateQuickness(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].quickness = value * boids[i].quicknessCoefficient;
    boids[i].maxSpeed = speedIndex * boids[i].quickness;
  }
}

// Racism
var racismControlContainer = document.getElementById('racism-control-container');
var racismInput = document.getElementById('racism');
racismInput.onchange = function() {
  racism = this.value / 5;
  updateRacism(racism);
}
var racismMobile = document.getElementById('racism-mobile');
racismMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  racismControlContainer.classList.toggle('show');
}
function updateRacism(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].racism = value * boids[i].racismCoefficient;
  }
}

// Diversity
var diversityControlContainer = document.getElementById('diversity-control-container');
var diversityInput = document.getElementById('diversity');
diversityInput.onchange = function() {
  diversity = this.value;
  updateDiversity(diversity);
}
var diversityMobile = document.getElementById('diversity-mobile');
diversityMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  diversityControlContainer.classList.toggle('show');
}
function updateDiversity(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].color = colors[ i % value ];
  }
}

/*---- end Inputs ----*/

  
  </script>
</body>
</html>
